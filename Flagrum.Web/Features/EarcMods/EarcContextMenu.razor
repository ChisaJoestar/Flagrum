@using Flagrum.Web.Persistence.Entities
@using System.IO.Compression
@using System.IO
@using System.Text
@using Flagrum.Core.Utilities
@using Flagrum.Web.Features.EarcMods.Data
@using Microsoft.EntityFrameworkCore
@using Newtonsoft.Json

@inject IWpfService WpfService
@inject FlagrumDbContext Context

<ContextMenu Id="earcContextMenu"
             OverrideDefaultCssClass="fixed select-none bg-grey-700 p-0 border-0 shadow-md"
             OverrideDefaultListCssClass="p-0"
             Direction="ContextMenuDirection.Right">
    <Item OnClick="async () => await Export((EarcMod)context.Data)"
          OverrideDefaultCssClass="text-grey-200 text-sm p-3 hover:bg-grey-600 cursor-pointer transition-colors">
        <div class="row">
            <span class="material-icons mr-3" style="font-size: 0.9rem">open_in_new</span>
            <span>Export Mod Pack</span>
        </div>
    </Item>
</ContextMenu>

@code
{
    [CascadingParameter] public Index Parent { get; set; }
    
    private async Task Export(EarcMod mod)
    {
        var defaultName = mod.Name.ToLower().Replace(" ", "_") + ".zip";
        const string filter = "ZIP Archive|*.zip";
        await WpfService.OpenSaveFileDialogAsync(defaultName, filter, async savePath =>
        {
            await InvokeAsync(() => Parent.SetLoading(true, "Exporting Mod Pack"));

            await Task.Run(() =>
            {
                var earcMod = Context.EarcMods
                    .Include(m => m.Earcs)
                    .ThenInclude(e => e.Replacements)
                    .Where(m => m.Id == mod.Id)
                    .AsNoTracking()
                    .ToList()
                    .FirstOrDefault()!;
                
                var metadata = new[] {earcMod}
                    .Select(m => new EarcModMetadata
                    {
                        Name = m.Name,
                        Author = m.Author,
                        Description = m.Description,
                        Replacements = m.Earcs.ToDictionary(
                            e => e.EarcRelativePath,
                            e => e.Replacements.Select(r => r.Uri))
                    })
                    .FirstOrDefault()!;

                using var stream = new FileStream(savePath, FileMode.Create);
                using var zip = new ZipArchive(stream, ZipArchiveMode.Create, true);

                foreach (var earc in earcMod.Earcs)
                {
                    foreach (var replacement in earc.Replacements)
                    {
                        var entry = zip.CreateEntry($"{Cryptography.HashFileUri64(replacement.Uri)}.{replacement.ReplacementFilePath[(replacement.ReplacementFilePath.LastIndexOf('.') + 1)..]}", CompressionLevel.Optimal);
                        using var entryStream = entry.Open();
                        entryStream.Write(File.ReadAllBytes(replacement.ReplacementFilePath));
                    }
                }
                
                var json = JsonConvert.SerializeObject(metadata);
                var jsonEntry = zip.CreateEntry("flagrum.json", CompressionLevel.Optimal);
                using (var jsonStream = jsonEntry.Open())
                {
                    jsonStream.Write(Encoding.UTF8.GetBytes(json));
                }

                var thumbnail = $@"{IOHelper.GetWebRoot()}\EarcMods\{earcMod.Id}.png";
                var thumbnailEntry = zip.CreateEntry("flagrum.png", CompressionLevel.Optimal);
                using var thumbnailStream = thumbnailEntry.Open();
                thumbnailStream.Write(File.ReadAllBytes(thumbnail));
            });
            
            await InvokeAsync(() => Parent.SetLoading(false));
        });
    }
}
