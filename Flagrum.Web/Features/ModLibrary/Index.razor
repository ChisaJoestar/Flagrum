@page "/"
@using Flagrum.Core.Archive
@using Flagrum.Core.Utilities
@using System.Collections.Concurrent
@using System.IO

@inject NavigationManager Navigation
@inject SettingsService Settings
@inject AppStateService AppState
@inject ILogger<Index> Logger
@inject BinmodTypeHelper BinmodTypeHelper
@inject JSInterop Interop
@inject ModelReplacementPresets ModelReplacementPresets

<LoadingView Text="Loading Mods"
             IsLoading="IsLoading">
    <div class="flex flex-row items-start px-7 pb-5 border-b border-t border-dark-600 sticky top-0 z-40 bg-dark">
        <div class="flex flex-row flex-wrap flex-grow">
            <div class="bg-dark-600 shadow-md rounded row mt-5 mr-10">
                <ModTypeButtonGroup Target="AppState.ActiveCategoryFilter" OnItemSelected="FilterCategory">
                    <ModTypeButton Text="Local Mods" Value="0"/>
                    <ModTypeButton Text="Workshop Mods" Value="1"/>
                    <ModTypeButton Text="All Mods" Value="-1"/>
                </ModTypeButtonGroup>
            </div>
            <div class="bg-dark-600 shadow-md rounded row mt-5 mr-6">
                <ModTypeButtonGroup Target="AppState.ActiveModTypeFilter" OnItemSelected="FilterType">
                    <ModTypeButton Text="All Mods" Value="-1"/>
                    <ModTypeButton Text="Outfits" Value="(int)BinmodType.Cloth"/>
                    <ModTypeButton Text="Weapons" Value="(int)BinmodType.Weapon"/>
                    <ModTypeButton Text="Replacements" Value="(int)BinmodType.Character"/>
                    <ModTypeButton Text="Comrades Styles" Value="(int)BinmodType.StyleEdit"/>
                    <ModTypeButton Text="Comrades Weapons" Value="(int)BinmodType.Multi_Weapon"/>
                </ModTypeButtonGroup>
            </div>
            <div class="flex-grow"></div>
            <div class="bg-dark-600 shadow-md rounded row mt-5 px-4">
                <span class="text-accent1-200 font-display text-lg">
                    @AppState.Mods.Count(m => (AppState.ActiveCategoryFilter == -1 || m.IsWorkshopMod == (AppState.ActiveCategoryFilter == 1)) && (AppState.ActiveModTypeFilter == -1 || m.Type == AppState.ActiveModTypeFilter))
                    &nbsp;&nbsp;/&nbsp;&nbsp;@AppState.Mods.Count(m => AppState.ActiveModTypeFilter == -1 || m.Type == AppState.ActiveModTypeFilter)&nbsp;&nbsp;/&nbsp;&nbsp;@Limits[AppState.ActiveModTypeFilter]
                </span>
            </div>
        </div>
    </div>

    <div class="flex flex-row" style="height: calc(100% - 74px)">
        <div class="flex-grow pt-2">
            <div class="row flex-wrap px-4 ml-0.5 mb-8">
                <CascadingValue Value="this">
                    <NewCard/>
                    <ModListingGroup Mods="AppState.Mods.Where(m => (AppState.ActiveCategoryFilter == -1 || m.IsWorkshopMod == (AppState.ActiveCategoryFilter == 1)) && (AppState.ActiveModTypeFilter == -1 || m.Type == AppState.ActiveModTypeFilter)).OrderByDescending(m => m.IsApplyToGame).ThenBy(m => m.Type).ThenBy(m => m.Target).ThenBy(m => m.GameMenuTitle ?? m.WorkshopTitle)"/>
                </CascadingValue>
            </div>
        </div>
        <div class="h-full py-6 pr-5 pl-2" style="flex: 0 0 242px;">
            <strong class="font-display block ml-2 text-grey-300 mb-3 text-lg">Browse Workshop Mods</strong>
            <small class="block text-grey-500 ml-2">
                Only Flagrum mods will appear in results
                due to older modding tools not applying tags to listings
            </small>
            <div class="pl-2 mt-6">
                <SteamWorkshopLink Text="All Flagrum Mods" Tags="@(new[] {"Flagrum"})"/>
            </div>
            <SteamWorkshopLinkGroup Title="Outfit Mods" DefaultExpanded="true">
                @foreach (var outfit in Enum.GetValues<OutfitSoloTarget>())
                {
                    <SteamWorkshopLink Text="@outfit.ToString()" Tags="@(new[] {"Outfit", outfit.ToString()})"/>
                }
            </SteamWorkshopLinkGroup>
            <SteamWorkshopLinkGroup Title="Weapon Mods" DefaultExpanded="true">
                @foreach (var weapon in Enum.GetValues<WeaponSoloTarget>())
                {
                    <SteamWorkshopLink Text="@weapon.ToString()" Tags="@(new[] {"Weapon", weapon.ToString()})"/>
                }
            </SteamWorkshopLinkGroup>
            <SteamWorkshopLinkGroup Title="Model Replacements">
                @foreach (var replacement in DefaultReplacements)
                {
                    <SteamWorkshopLink Text="@replacement.Name" Tags="@(new[] {"Model Replacement", replacement.Name})"/>
                }
                <SteamWorkshopLink Text="Other" Tags="@(new[] {"Model Replacement", "Other"})"/>
            </SteamWorkshopLinkGroup>
            <SteamWorkshopLinkGroup Title="Comrades Styles">
                @foreach (var style in Enum.GetValues<OutfitMultiTarget>())
                {
                    <SteamWorkshopLink Text="@style.ToString()" Tags="@(new[] {"Comrades Style", style.ToString()})"/>
                }
            </SteamWorkshopLinkGroup>
            <SteamWorkshopLinkGroup Title="Comrades Weapons">
                @foreach (var weapon in Enum.GetValues<WeaponMultiTarget>())
                {
                    <SteamWorkshopLink Text="@weapon.ToString()" Tags="@(new[] {"Comrades Weapon", weapon.ToString()})"/>
                }
            </SteamWorkshopLinkGroup>
        </div>
    </div>
</LoadingView>

@code
{
    [CascadingParameter]
    public MainLayout Parent { get; set; }

    private bool IsLoading { get; set; }

    private Dictionary<int, int> Limits { get; } = new()
    {
        {-1, 50 + 999 + 100 + 100 + 999},
        {(int)BinmodType.Cloth, 50},
        {(int)BinmodType.Character, 999},
        {(int)BinmodType.Weapon, 100},
        {(int)BinmodType.Multi_Weapon, 100},
        {(int)BinmodType.StyleEdit, 999}
    };

    private List<ModelReplacementTarget> DefaultReplacements { get; set; }

    protected override async void OnInitialized()
    {
        DefaultReplacements = ModelReplacementPresets.GetDefaultReplacements();
        if (!AppState.IsModListInitialized)
        {
            await Task.Run(() =>
            {
                var binmodList = ModlistEntry.FromFile(Settings.BinmodListPath);
                var localMods = Directory.GetFiles(Settings.ModDirectory, "*.ffxvbinmod", SearchOption.TopDirectoryOnly);
                IEnumerable<string> allMods;

                if (Directory.Exists(Settings.WorkshopDirectory))
                {
                    var workshopMods = Directory.GetFiles(Settings.WorkshopDirectory, "*.ffxvbinmod", SearchOption.AllDirectories);
                    allMods = localMods.Union(workshopMods);
                }
                else
                {
                    allMods = localMods;
                }

                var mods = new ConcurrentBag<Binmod>();

                Parallel.ForEach(allMods, file =>
                {
                    using var unpacker = new Unpacker(file);
                    var modmetaBytes = unpacker.UnpackFileByQuery("index.modmeta", out _);
                    var mod = Binmod.FromModmetaBytes(modmetaBytes, BinmodTypeHelper, Logger);
                    var previewBytes = unpacker.UnpackFileByQuery("$preview.png.bin", out _);

                    var binmodListing = binmodList.FirstOrDefault(e => file.Contains(e.Path.Replace('/', '\\')));

                    if (mod == null)
                    {
                        Logger.LogWarning($"Could not read modmeta from {file}");
                        return;
                    }

                    if (binmodListing == null)
                    {
                        Logger.LogWarning($"Could not find binmod.list entry for {file}");
                        return;
                    }

                    mod.Description = mod.Description?.Replace("\\n", "\n");
                    mod.GameMenuDescription = mod.GameMenuDescription?.Replace("\\n", "\n");
                    mod.IsWorkshopMod = binmodListing.IsWorkshopMod;
                    mod.Index = binmodListing.Index;
                    mod.IsApplyToGame = binmodListing.IsEnabled;
                    mod.Path = file;
                    File.WriteAllBytes($"{IOHelper.GetWebRoot()}\\images\\{mod.Uuid}.png", previewBytes);

                    mods.Add(mod);
                });

                AppState.Mods = mods.ToList();
                var paths = AppState.Mods.Select(m => m.Path);
                AppState.UnmanagedEntries = binmodList.Where(e => !paths.Any(p => p.Contains(e.Path.Replace('/', '\\')))).ToList();
            });

            ClearOldImages();
            AppState.IsModListInitialized = true;
        }

        StateHasChanged();
    }

    private async void ClearOldImages()
    {
        await Task.Run(() =>
        {
            var exceptions = AppState.Mods.Select(m => $"{IOHelper.GetWebRoot()}\\images\\{m.Uuid}.png");
            foreach (var image in Directory.EnumerateFiles($"{IOHelper.GetWebRoot()}\\images"))
            {
                if (!exceptions.Contains(image))
                {
                    File.Delete(image);
                }
            }
        });
    }

    private void FilterType(int type)
    {
        AppState.ActiveModTypeFilter = type;
        StateHasChanged();
    }

    private void FilterCategory(int category)
    {
        AppState.ActiveCategoryFilter = category;
        StateHasChanged();
    }
}